#lang racket

; this module defines a subset of nondeterministic-finite-automata generated by
; the McNaughton-Yamada-Thompson algorithm that builds an NFA from a regular
; expression. Those automata have the following properties
; * The always have a single final state
; * The final state has no transitions
; * A Given state has as many e-transitions as possible, but a single labelled
;   transition (it may also have only e-transitions)
; This module also define the algorithm itself

; struct representing a state of an NFA where:
; * etrans is the set of states accessible after an e-transition from the state
; * trans is a pair (ch, st) where ch is an input char and st a destination,
;   or '() if this state has no transitions
; * a number, set to 'na or to a state number when it's generated
(struct st (etrans trans num) #:mutable)

; struct representing an NFA where
; * init-st points to the initial state
; * final-st point to the final state
(struct auto (init-st final-st))

(define (new-st)
  (st (seteq) '() 'na))

(define (to-dot nfa)
  (let ((cur 0))
    (display "digraph automata {\n")
    (display "\trankdir = LR;\n")
    (display "\tsize = \"4,4\";\n")
    (display "\tnode [shape=box]; 0;\n")
    (display "\tnode [shape=circle];\n")
    (letrec ((iter
               (lambda (nfa)
                 (if (eq? (st-num nfa) 'na)
                   (let ((num cur))
                     (set-st-num! nfa cur)
                     (set! cur (+ cur 1))
                     (set-for-each
                       (st-etrans nfa)
                       (lambda (s)
                         (let ((n (iter s)))
                           (display "\t")
                           (display num)
                           (display " -> ")
                           (display n)
                           (display " [label=\"e\"]\n"))))
                     (let ((p (st-trans nfa)))
                       (when (pair? p)
                         (let ((n (iter (cdr p))))
                           (display "\t")
                           (display num)
                           (display " -> ")
                           (display n)
                           (display " [label=\"")
                           (display (car p))
                           (display "\"]\n"))))
                     (st-num nfa))
                   (st-num nfa)))))
      (iter (auto-init-st nfa)))
    (display "\tnode [shape=doublecircle];")
    (display " ") (display (st-num (auto-final-st nfa)))
    (display ";\n")
    (display "}\n")))

(define (regex-to-nfa reg)
  (if (pair? reg)
    (let ((op (car reg))
          (args (cdr reg)))
      (case op
        ('* (let ((sub (regex-to-nfa (car args)))
                  (new-init (new-st))
                  (new-final (new-st)))

              ; the new initial state transitions to the old initial state
              ; and to the new final state, to short-circuit the expression
              (set-st-etrans! new-init (seteq (auto-init-st sub)
                                              new-final))

              ; the old final state is not final anymore and transitions to
              ; the new final state and the old initial state to allow repeat
              (let ((old-final (auto-final-st sub)))
                (set-st-etrans! old-final (seteq new-final (auto-init-st sub))))

              ; the new states are the only initial and final states
              (auto new-init new-final)))

        ('or (let ((subl (regex-to-nfa (car args)))
                   (subr (regex-to-nfa (cadr args)))
                   (new-init (new-st))
                   (new-final (new-st)))

               ; the new initial transitions to both initial states of the sub
               ; automatas
               (set-st-etrans! new-init (seteq (auto-init-st subl)
                                               (auto-init-st subr)))

               ; the old final states transition to the new final state
               (let ((old-final-l (auto-final-st subl))
                     (old-final-r (auto-final-st subr)))
                 (set-st-etrans! old-final-l (seteq new-final))
                 (set-st-etrans! old-final-r (seteq new-final)))

               (auto new-init new-final)))

        (else ; it's a regex, so a concatenation
          (letrec ((concat
                     (lambda (reg)
                       (cond
                         ((null? reg) reg) ; concat of nothing, should fail?
                         ((null? (cdr reg)) (regex-to-nfa (car reg)))
                         (else
                           (let ((subl (regex-to-nfa (car reg)))
                                 (subr (concat (cdr reg))))

                             ; concatenation of 2 automata. we remove the
                             ; initial state of the second automata and
                             ; give its transitions to the final state of
                             ; the first automate
                             (let ((old-final (auto-final-st subl))
                                   (new-final (auto-final-st subr))
                                   (old-init (auto-init-st subr)))
                               (set-st-trans! old-final (st-trans old-init))
                               (set-st-etrans! old-final (st-etrans old-init))
                               (auto (auto-init-st subl) new-final))))))))
            (concat reg)))))

    ; it's just a char
    (let* ((init (new-st))
           (final (new-st)))
      (set-st-trans! init (cons reg final))
      (auto init final))))

; computes the set of states accessible after transitionning from the states
; contained in the given set of states
(define (eclosure set)
  (define (iter stack ret)
    (if (set-empty? stack) ret
      (let ((fst (set-first set)))
        (map
          (lambda (s)
            (when (not (set-member? s ret))
              (begin
                (set! ret (set-add s ret))
                (set! set (set-add s ret))))
            (st-etrans fst)))
        (iter set ret))))
  (iter set))
